{"name":"Dreadlogs","tagline":"","body":"dread-logs\r\n==========\r\n\r\n[![Build Status](https://travis-ci.org/d-lorenc/dread-logs.svg?branch=master)](https://travis-ci.org/d-lorenc/dread-logs) [![Coverage Status](https://coveralls.io/repos/d-lorenc/dread-logs/badge.png?branch=master)](https://coveralls.io/r/d-lorenc/dread-logs?branch=master)\r\n\r\nA Java library for testing logs. It supports most commonly used logging libraries, namely [log4j](http://logging.apache.org/log4j), [Logback](http://logback.qos.ch/) and Java logging framework (JUL = java.util.logging). It is aimed for unit testing (TDD) but can also be used in integration and functional tests as long as they run in the same JVM as your system under test.\r\n\r\nexample\r\n------\r\n```java\r\n@Test\r\npublic void shouldCaptureLogWithMessage() throws Exception {\r\n    //create a log captor which attaches an extra appender to collect logs in memory\r\n    Log4jCaptor captor = new Log4jCaptor(\"me.lorenc.dreadlogs\");\r\n\r\n    //execute code which logs something\r\n    Logger logger = Logger.getLogger(\"me.lorenc.dreadlogs.some.package\");\r\n    logger.info(\"a message\");\r\n\r\n    //verify that the captor has your log message\r\n    assertThat(captor, hasLog(\"a message\").onLevel(INFO));\r\n\r\n    //clean up - by detaching appender you make sure it stops collecting any further logs, otherwise you may end up with OOME\r\n    captor.detachAppender();\r\n}\r\n```\r\nor like this:\r\n```java\r\nprivate Logger logger;\r\nprivate Log4jCaptor captor;\r\n\r\n@Before\r\npublic void before() throws Exception {\r\n    logger = Logger.getLogger(\"me.lorenc.dreadlogs.some.package\");\r\n    captor = new Log4jCaptor(\"me.lorenc.dreadlogs\");\r\n}\r\n\r\n@After\r\npublic void after() throws Exception {\r\n    captor.detachAppender();\r\n}\r\n\r\n@Test\r\npublic void shouldCaptureLogWithMessageSimples() throws Exception {\r\n\r\n    logger.info(\"a message\");\r\n\r\n    assertThat(captor, hasLog(\"a message\"));\r\n}\r\n```\r\n<dd>* hasLog is a static method in me.lorenc.dreadlogs.captor.log4j.Log4jMatchers</dd>\r\n\r\nFor more examples, please check out functional tests:\r\n* [log4j](https://github.com/d-lorenc/dread-logs/tree/master/src/test/java/me/lorenc/dreadlogs/captor/log4j/functional)\r\n* [logback](https://github.com/d-lorenc/dread-logs/tree/master/src/test/java/me/lorenc/dreadlogs/captor/logback/functional)\r\n* [jul](https://github.com/d-lorenc/dread-logs/tree/master/src/test/java/me/lorenc/dreadlogs/captor/jul/functional)\r\n\r\ninstall\r\n-------\r\n##### maven\r\n```xml\r\n<dependency>\r\n    <groupId>me.lorenc.dreadlogs</groupId>\r\n\t<artifactId>dreadlogs</artifactId>\r\n\t<version>0.1</version>\r\n</dependency>\r\n```\r\n##### gradle\r\n```\r\n'me.lorenc.dreadlogs:dreadlogs:0.1'\r\n```\r\n##### sbt\r\n```\r\nlibraryDependencies += \"me.lorenc.dreadlogs\" % \"dreadlogs\" % \"0.1\"\r\n```\r\n##### dependencies\r\nHamcrest, and of course a logging library of your choice (log4j or logback-classic), which you should already have in your project.  \r\n\r\nhow it works\r\n------------\r\nIt uses log appenders which attach to the logging library and capture and store log events in memory. A few available matchers allow for easy assertions. Apart from checking for a log message, the matchers let you specify expected level, logger name (package), exception details or even MDC values.\r\n\r\nwhy \"capturing appenders\"\r\n------------------------\r\nThere is definitely more than one way to test the logs. In a unit test a logger can be mocked. That way any interactions with the logger API can be verified. The other extreme would be writing logs to a file (or a stream) and test the actual file/stream content, including line formatting etc. That is not ideal for unit testing (involves file system), but may be preferable for functional tests.\r\nThe \"capturing appender\" is a solution in the middle, which is fast and isolated enough for unit testing. At the same time it can be applied in other types of tests, as long as they run in the same JVM as the systems which writes the logs. A good example would be a lightweight independent system component which can run on its own (e.g. inside embedded container). \r\nSuch a component can be started from a test, which means that everything can run within the same JVM.\r\n\r\nmotivation\r\n----------\r\nI have been working on many agile projects, where we would follow TDD and/or BDD principles, and quite often write some tests to check logs too. Unfortunately I haven't come across any library which would help in that. I would usually create some sort of in-memory-appender with a bunch of classes to make log assertions neat and simple. And I would repeat the same process for many projects (different logging framework, employer). So here is my attempt to create a library, which covers the most common Java log frameworks, and simplifies verification of logs in tests. As this makes testing logs quite trivial, you may even stop asking yourself whether you should be testing logs or not.\r\n\r\njava version\r\n------------\r\n1.5 or later\r\n","google":"UA-57513984-1","note":"Don't delete this file! It's used internally to help with page regeneration."}